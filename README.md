# Ant-Sim-Go
This is an Ant Colony Simulation I've been working on building on my local machine for a couple weeks now. I decided to put my spaghetti code for it on GitHub.

This project is written 100% in the Go Programming Language, using the go-gl and go-glfw modules that wrap the C-based interface for OpenGL in Go so they can be used in Go projects.

# Structures
- Pair: a set of two integer values X and Y that are used for tracking what cell each ant is in
- Vertex: used to track visited vertices by the ants, for the adjacency list to use to know what two vertices connect to form an edge
- Edge: Contains the vertex that is gone to as well as the edge weight (the vertex you're traveling from is tracked by a map inside of the Graph structure)
- Graph: Contains an array of visited vertices and a map that maps a Vertex (a Pair) to a list of Edges (i.e., graph.edge[Pair{x, y}] shows a list of all other connected vertices to the x, y vertex as well as the weight of those edges, which is a pointer to a float32 value). Has two methods attached:
    - AddVertex() takes a pair argument, and stores that pair into the vertex list
    - AddEdge() takes two pair arguments (to and from) and a pointer to a float32 argument. maps to the from pair the Edge{to pair, pointer to float32} and appends it to the list of Edges that are mapped to that from pair. 
- Colours: A slice/list of pointers to float32 values. This is use to track the fading of pheromone trails
- Cell: The largest structure in the project, tracks the state of independent cells within the ant colony simulation. Tracks if it's a drawable cell or not, tracks if it's a nest cell, a food cell, a home pheromone cell, a food pheromone cell, or an ant cell. Tracks the rate of decay for and the remaining amount of any home pheromones and food pheromones in the cell (these pheromones are treated separately). Tracks the point in time which home pheromones and food pheromones were dispensed into the cell (used to ensure the cell contains those pheromones for at least 8 seconds before allowing them to decay). Tracks the color of the pheromone trail (white for home pheromones, blueish-purple for food pheromones). Has two methods:
    - Draw() determines if the cell is of a drawable type by observing if the cell is either a nest, food, a home pheromone, a food pheromone, or an ant, and marks it drawable if it is any one of those, else it is not a drawable cell and returns
    - PheromoneDraw() updates the pheromone color in the cell so that it can be drawn the correct color (white for a home pheromone, blueish-purple for a food pheromone)
- Ant: The structure for the ants, contains the ant's current and previous position as Pairs, tracks the pheromone type that the ant is currently given off as a bool (false for home pheromone, true for food pheromone), the strength of the pheromones it's giving off (used as the value deposited into the cell for its pheromones), it's homebase/spawn coordinates as a Pair (used by the adjacency list to coordinate the ant's way back home), hasFood as a bool to denote if the ant is currently carrying food, foundFood to denote if the ant has found food (even if it's not currently carrying any), direction as a string that tells the ant's current cardinal direction of travel, and travel as a Pair used to tell the ant how many x, y spaces it's going to move in the next execution cycle. Has seven methods:
    - NoFoodMove() tells the ant how it's going to move (pseudo-randomly) when it has not found any food at all
    - GenerateCardinal() uses a randomly-generated float64 value to generate a probability of the ant changing its cardinal direction, returns the new cardinal direction and stores it in the ant structure's direction value.
    - FoundFoodMove() takes three arguments, the two-dimensional array containing pointers to the individual cells of the ant colony simulation, a pointer to the graph used to path the ant back to the nest from the food cluster, a pointer to a mutex to lock access and prevent concurrent read/writes to the graph. This method uses the map of Edge lists to get the ant back to the nest by following the edges with the largest weights.
    - CheckFood() takes one argument, the two-dimensional array of pointers to the individual cells. This method checks the cells within a one-block radius around the ant for whether any of the cells are marked as food, and updates the ant's next travel to go in the direction of that food while marking that the ant has found food, so it can begin using the adjacency list to return back home.
    - MoveHungryAnt() takes three arguments, the two-dimensional array containing cell pointers, a pointer to the graph that leads back home, and a pointer to a mutex. This method is used to take the values generated by NoFoodMove() and GenerateCardinal() to then update the ant's position. Only called if the ant has not found food (hence why it's a "Hungry Ant").
    - BringHome() takes five arguments, the two-dimensional array containing cell pointers, a pointer to the graph that leads back home, a pointer to the graph that leads back to the food, a pointer to an integer used to update the count of food brought home, and a pointer to a mutex. This method is used to path the ant back home to the nest after it has found and currently has food.
    - Move() takes five arguments, the two-dimensional array containing cell pointers, a pointer to the graph that leads back home, a pointer to the graph that leads back to the food, a pointer to an integer used to update the count of food brought home, and a pointer to a mutex. This is the driver method for the other six methods, as all six other methods are called from within this method based on various if-else-if conditions (if ant hasFood, if not ant FoundFood, if not ant HasFood, if ant FoundFood and not ant HasFood, etc.).

# How to run
Make sure you have OpenGL on your GPU (most GPU's come with it already, so you're likely already good there). If pulling from GitHub, run "go mod tidy" to pull the dependencies for go-gl and go-glfw. Then you can run by doing either "go build main.go" and then running the compiled .exe file, or you can do "go run main.go" to build and run it at once. There's also an .exe included that you can just run like any other .exe file (double-click it, or from a powershell terminal inside of the project directory, use "./main.exe").

# What works?
Well, almost everything! The list of things that doesn't work is much shorter. 
- The ants use an adjacency list to track where they've been, and each vertex is mapped to a list of edges that involve that vertex that are weighted based on the home pheromone value in that vertex, or cell. 
- They then choose the edge that's marked as the "heaviest" based on that pheromone value, which is a pointer to the cell's individual home pheromone value. 
- The pheromone value for home starts at a beta value of 0.65 and decays at a rate of 0.02 per cycle, but decay only begins after the cell has contained pheromones for 8 seconds. This decay is reflected in the white trails the ants leave behind, as those trails will fade away at the same rate, although the trails seem to disappear long before the pheromones themselves do, and even if the pheromones and trails disappear entirely, the adjacency list still contains the edge, so the ants will still be able to make it back home to the nest.
- They use a separate adjacency list to find their way from the food back home. This adjacency list is essentially the inverse of the first one, where it tracks the edges in reverse, and instead of using the home pheromones for edge weight, it uses the food pheromones, tracked as separate float32 values inside of each cell. 
- The nest is spawned around a randomly-chosen central point and expanded to be a 3x3 block where each cell in that 3x3 is marked as "nest". 
- The same logic for spawning a nest applies to the "food" spawn.
- The ants (a total of 8) are spawned around the edges of the central spawn of the nest itself, with each ant being assigned a pre-determined cardinal direction (north, south, east, west, northeast, northwest, southeast, southwest) based on what part of the nest it spawns in (i.e., the top-left corner ant will go in the northwest direction to start, and the bottom-right corner ant will go southeast, etc.). 
- Every 1000 milliseconds (I believe it's that long, if not, it's 1000 nanoseconds, I know, that's a huge difference), the ants will try and change their direction based on their currently assigned cardinal direction. There's also a random float64 value that will generate a probability that the ant's cardinal direction will change as well on the same time interval.
- The ants are able to collide with an existing food pheromone trail and, using the foodPath adjacency list, are able to start following that trail to the food immediately.
- The count of how much food has been gathered prints in the console.
- The movement of the ants are the only thing that's parallelized, as OpenGL requires all interactions with its interface to be on the main operating system thread, meaning only the things that are separate from OpenGL, like the tracking of the cell states in the background, where the ants are, where the nest is, the food is, where pheromone trails are, etc. are all that can be parallelized, and all of this happens within the Move() function that's part of the Ant structure.

# What doesn't work?
- There's around a 15-20% chance the program will crash either immediately when running it or within the first 10 seconds of running, and I would estimate maybe a 2-5% chance of crashing when it's been running for around a minute or longer, but in most cases, the program will run for several minutes, allowing each ant to find food, either on its own or with the help of a food pheromone trail, and be able to bring food home up to over 100 times. You may need to run it a few times to see it "work" fully. The Queen will not go hungry.
- Far as I can tell, this crashing behavior is related to something inside of the runtime module itself, as the stack calls that are given as an error when the crash happens always source back to the "cgo toolchain" when it's being used by the runtime module. I have not been able to find the source of the intermittent crashing, I tried looking into it and it seems like it's a known issue with an unknown source that's not being worked on.
- The food cluster does not deplete over time. I tried implementing that behavior, but the ants do not properly route to the new piece of the food cluster when the piece they were routing to ends up being depleted. I didn't have time to figure out how to fix this (though I'm sure I could have, with more time).

# Resources
- AI was helpful in getting a starter function for the movement of the ants, but since the starter function given wasn't including any graphics library, parallelization, or ant logic, it was too basic for what I needed, and what I ended up with for movement logic was so far from that starter function that it doesn't resemble anything that Copilot gave me. I don't even think I ended up using it just because I knew it was far too simple for what I needed. ("ant colony movement")
- AI was helpful in giving me an example of how maps work in Golang, and how they can be used to make an adjacency list. This was a much better use case, but even that evolved far beyond what Copilot gave. Still, it was incredibly helpful, though it didn't give me much insight into what maps really were. ("adjacency list golang")
- Google was helpful in explaining what maps were in Golang, a way to "map" a value or pair of values to other values or pairs of values. I ended up using a map that mapped a pair of ints (wrapped in my own "Pair" structure) to slices of "Edges" which were other Pairs and to associated weights. ("what are maps in golang")
- Using my cell structure from Conway's as well as the OpenGL boilerplate for creating a window was the bulk of getting this project off the ground ("github.com/SmoCloud/Conway-GOL")
- The OpenGL documentation for drawing was also very helpful, moreso on the Wumpus project, but even with this one, it helped me understand better how draws worked, and why they worked how they did ("https://open.gl/drawing") - This turned out to be the most useful by far.
- AI also helped with providing an example of using uniforms for changing cell colors dynamically without having to write a separate shader to do it ("change cell color opengl glfw golang"), which was touched on in the OpenGL documentation for drawing.

# Reflecting on the use of AI
- If the problem you're asking it for is small, it's good for providing simple use cases that can be great for referencing as examples of how to implement that solution on a larger scale or within your specific use case, but asking it to do it for you, to the scale and complexity you want, within your specific use case, is a complete waste of time, which is why I didn't bother asking it for much throughout this project except for simple how-to's (such as how to make an adjacency list in golang, that was useful, but if I had asked it to make an adjacency list to track the movement of ants in an ant colony simulation, it wouldn't have given me something I could reference to ultimately end up implementing myself, and if it had, it would have required refitting the rest of the project for that one aspect to work since it knew nothing about the codebase I was working in).